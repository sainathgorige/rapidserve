---
- name: Deploy Infrastructure with Docker Containers for Edge and Origin Servers
  hosts: hostvms
  gather_facts: no
  become: True  
  become_method: sudo

  vars:
    container_num: 1 
    server_type: "edge"
    vpc_name: "nf_in"
    origin_vm_ip: 10.10.10.10
    container_name: "{{ vpc_name }}_container{{ container_num }}" 
    subnets: ["bri_9"] 
    hash_name: "{{ container_name | hash('sha1') }}"
    short_name: "{{ container_name }}"

  tasks:
    - name: Extract parts of the container name
      set_fact:
        short_name: "{{ container_name[:4] + container_name[-2:] }}"
    - name: Check if network namespace exists
      command: ip netns list | grep -w {{ vpc_name }}
      register: ns_check
      failed_when: ns_check.stdout == ""

    - name: Fail if network namespace does not exist
      fail:
        msg: "Namespace {{ vpc_name }} does not exist. Please run 'deploy_infra' to create the namespace first."
      when: ns_check.stdout == ""

    - name: Create NGINX configuration file from template for edge servers
      template:
        src: "nginx-{{ server_type }}.conf.j2"
        dest: "{{ playbook_dir }}/nginx-{{ container_name }}.conf"

    - name: Conditionally create index.html for origin servers
      template:
        src: "index.html.j2"
        dest: "{{ playbook_dir }}/index.html"
      when: server_type == 'origin'

    - name: Copy Dockerfile to the remote host
      copy:
        src: "Dockerfile-{{ server_type }}"
        dest: "/tmp/Dockerfile-{{ server_type }}"

    - name: Update the base image to a recent version
      command: docker pull 100514735019/customnginx

    - name: Build Docker image with custom NGINX config
      community.docker.docker_image:
        name: "{{ container_name }}"
        tag: "latest"
        build:
          path: "/tmp"
          dockerfile: "Dockerfile-{{ server_type }}"
          args:
            NGINX_CONF: "nginx-{{ container_name }}.conf"
          nocache: true
          rm: true
        state: present
        source: build

    # - name: Build Docker image with custom NGINX config
    #   community.docker.docker_image:
    #     name: "{{ container_name }}"
    #     tag: "latest"
    #     build:
    #       path: "{{ playbook_dir }}"
    #       dockerfile: "Dockerfile-{{ server_type }}"
    #       args:
    #         NGINX_CONF: "nginx-{{ container_name }}.conf"
    #       nocache: true
    #       rm: true
    #     state: present
    #     source: build

    - name: Create and start Docker container
      community.docker.docker_container:
        name: "{{ container_name }}"
        image: "{{ container_name }}:latest"
        state: started
        network_mode: none
        tty: true
        restart_policy: unless-stopped
        capabilities:
          - NET_ADMIN

    - name: Get container PID
      command: docker inspect --format '{''{.State.Pid}}' "{{ container_name }}"
      register: docker_pid

    - name: Link network namespace of container
      command: ln -sf /proc/{{ docker_pid.stdout }}/ns/net /var/run/netns/{{ container_name }}

    # Loop for setting up veth pairs and attaching them to subnets
    - name: Create veth pair for bridge {{ item }}
      command: ip link add  {{ short_name }} type veth peer name v_{{ short_name }}
      loop: "{{ subnets }}"

    - name: Bring up veth peer in host namespace for bridge {{ item }}
      command: ip link set v_{{ short_name }} up
      loop: "{{ subnets }}"

    - name: Attach veth interface to the bridge {{ item }}
      command: ip link set v_{{ short_name }} master {{ item }}_br
      loop: "{{ subnets }}"

    - name: Assign container network interface to veth for bridge {{ item }}
      command: ip link set {{ short_name }} netns {{ container_name }}
      loop: "{{ subnets }}"

    # - name: Assign IP address to the interface in container namespace for bridge {{ item }}
    #   command: ip netns exec {{ container_name }} ip addr add {{ container_ip }}/24 dev {{ short_name }}
    #   loop: "{{ subnets }}"

    - name: Bring up container network interface in container namespace for bridge {{ item }}
      command: ip netns exec {{ container_name }} ip link set {{ short_name }} up
      loop: "{{ subnets }}"

    - name: Start dhclient on container interface 
      command: "docker exec {{ container_name }} dhclient {{ short_name }}"
      loop: "{{ subnets }}"

    - name: Configure network interfaces and veth pairs
      shell: |
        set -x
        IP_ADDR=$(docker exec '{{ container_name }}' ip addr show ({short_name}} | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)
        if [ -n "$IP_ADDR" ]; then
          GATEWAY=$(echo $IP_ADDR | awk -F '.' '{printf "%d.%d.%d.1", $1, $2, $3}')
          DEFAULT_ROUTE=$(docker exec '{{ container_name }}' ip route | grep default)
          if [ -z "$DEFAULT_ROUTE" ]; then
            docker exec '{{ container_name }}' ip route add default via $GATEWAY
          fi
        fi
      loop: "{{ subnets }}"
      register: network_setup
      failed_when: "'Failed' in network_setup.stderr"

    # - name: Add default route in container
    #   command: "ip netns exec {{ container_name }} ip route add default via {{ container_gateway_ip }}"
    #   loop: "{{ subnets }}"
      
        
